template <int mod>
unsigned int down(unsigned int x){
    return x >= mod ? x - mod : x;
}
template <int mod>
struct Modint{
    unsigned int x;
    Modint() = default;
    Modint(unsigned int x) : x(x) {}
    friend istream &operator>>(istream &in, Modint &a) { return in >> a.x; }
    friend ostream &operator<<(ostream &out, Modint a) { return out << a.x; }
    friend Modint operator+(Modint a, Modint b) { return down<mod>(a.x + b.x); }
    friend Modint operator-(Modint a, Modint b) { return down<mod>(a.x - b.x + mod); }
    friend Modint operator*(Modint a, Modint b) { return 1ULL * a.x * b.x % mod; }
    friend Modint operator/(Modint a, Modint b) { return a * ~b; }
    friend Modint operator^(Modint a, int b){
        Modint ans = 1;
        for (; b; b >>= 1, a *= a)
            if (b & 1)
                ans *= a;       
        return ans;
    }
    friend Modint operator~(Modint a) { return a ^ (mod - 2); }
    friend Modint operator-(Modint a) { return down<mod>(mod - a.x); }
    friend Modint &operator+=(Modint &a, Modint b) { return a = a + b; }
    friend Modint &operator-=(Modint &a, Modint b) { return a = a - b; }
    friend Modint &operator*=(Modint &a, Modint b) { return a = a * b; }
    friend Modint &operator/=(Modint &a, Modint b) { return a = a / b; }
    friend Modint &operator^=(Modint &a, int b) { return a = a ^ b; }
    friend Modint &operator++(Modint &a) { return a += 1; }
    friend Modint operator++(Modint &a, int){
        Modint x = a;
        a += 1;
        return x;
    }
    friend Modint &operator--(Modint &a) { return a -= 1; }
    friend Modint operator--(Modint &a, int){
        Modint x = a;
        a -= 1;
        return x;
    }
    friend bool operator==(Modint a, Modint b) { return a.x == b.x; }
    friend bool operator!=(Modint a, Modint b) { return !(a == b); }
};
typedef Modint<998244353> mint;

using Poly = vector<mint>;

// 保留前 n 项
void shrink(Poly &f, int n) {
    if ((int)f.size() > n) f.resize(n);
}

// 计算 NTT 的原根
int get_primitive_root() {
    int g = 2;
    while (true) {
        bool ok = true;
        int m = mod - 1;
        for (int i = 2; i * i <= m; ++i) {
            if (m % i == 0) {
                if (mint(g).pow((mod - 1) / i).x == 1) {
                    ok = false;
                    break;
                }
                while (m % i == 0) m /= i;
            }
        }
        if (m > 1 && mint(g).pow((mod - 1) / m).x == 1) ok = false;
        if (ok) return g;
        ++g;
    }
}

// NTT 操作
void ntt(vector<mint> &a, bool invert) {
    int n = a.size();
    static vector<int> rev;
    static mint root = mint(get_primitive_root()).pow((mod - 1) / (1 << 20));
    static mint inv_root = root.inv();

    if ((int)rev.size() != n) {
        rev.resize(n);
        int lg = __builtin_ctz(n);
        for (int i = 0; i < n; ++i) {
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));
        }
    }

    for (int i = 0; i < n; ++i)
        if (i < rev[i]) swap(a[i], a[rev[i]]);

    for (int len = 2; len <= n; len <<= 1) {
        mint wlen = invert ? inv_root : root;
        for (int i = len; i < (1 << 20); i <<= 1)
            wlen *= wlen;
        for (int i = 0; i < n; i += len) {
            mint w = 1;
            for (int j = 0; j < len / 2; ++j) {
                mint u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }

    if (invert) {
        mint inv_n = mint(n).inv();
        for (mint &x : a) x *= inv_n;
    }
}

// 多项式乘法（基于 NTT）
Poly operator*(const Poly &a, const Poly &b) {
    int n = 1;
    while (n < (int)a.size() + (int)b.size() - 1) n <<= 1;
    vector<mint> A(n), B(n);
    for (int i = 0; i < (int)a.size(); ++i) A[i] = a[i];
    for (int i = 0; i < (int)b.size(); ++i) B[i] = b[i];
    ntt(A, false);
    ntt(B, false);
    for (int i = 0; i < n; ++i) A[i] *= B[i];
    ntt(A, true);
    A.resize(a.size() + b.size() - 1);
    return A;
}

// 多项式加法
Poly operator+(const Poly &a, const Poly &b) {
    Poly res(max(a.size(), b.size()));
    for (int i = 0; i < (int)a.size(); ++i) res[i] += a[i];
    for (int i = 0; i < (int)b.size(); ++i) res[i] += b[i];
    return res;
}

// 多项式减法
Poly operator-(const Poly &a, const Poly &b) {
    Poly res(max(a.size(), b.size()));
    for (int i = 0; i < (int)a.size(); ++i) res[i] += a[i];
    for (int i = 0; i < (int)b.size(); ++i) res[i] -= b[i];
    return res;
}

// 多项式乘常数
Poly operator*(const Poly &a, mint b) {
    Poly res = a;
    for (auto &x : res) x *= b;
    return res;
}

// 多项式导数
Poly deriv(const Poly &f) {
    Poly res(f.size() - 1);
    for (int i = 1; i < (int)f.size(); ++i)
        res[i - 1] = f[i] * i;
    return res;
}

// 多项式积分
Poly integ(const Poly &f) {
    Poly res(f.size() + 1);
    for (int i = 0; i < (int)f.size(); ++i)
        res[i + 1] = f[i] / mint(i + 1);
    return res;
}

// 多项式逆元
Poly inv(const Poly &f, int n) {
    Poly g(1, f[0].inv());
    for (int m = 1; m < n; m <<= 1) {
        Poly f_cut(f.begin(), f.begin() + min((int)f.size(), 2 * m));
        Poly t = g * g * f_cut;
        shrink(t, 2 * m);
        for (int i = 0; i < 2 * m; ++i) t[i] = -t[i];
        for (int i = 0; i < m; ++i) t[i] += mint(2) * g[i];
        g = t;
        shrink(g, 2 * m);
    }
    shrink(g, n);
    return g;
}

// 多项式 ln(f), 要求 f[0] = 1
Poly ln(const Poly &f, int n) {
    Poly res = integ(deriv(f) * inv(f, n));
    shrink(res, n);
    return res;
}

// 多项式 exp(f), 要求 f[0] = 0
Poly exp(const Poly &f, int n) {
    Poly g(1, 1);
    for (int m = 1; m < n; m <<= 1) {
        Poly ln_g = ln(g, 2 * m);
        Poly q = f;
        shrink(q, 2 * m);
        for (int i = 0; i < 2 * m; ++i) ln_g[i] = q[i] - ln_g[i];
        ln_g[0] += 1;
        g = g * ln_g;
        shrink(g, 2 * m);
    }
    shrink(g, n);
    return g;
}